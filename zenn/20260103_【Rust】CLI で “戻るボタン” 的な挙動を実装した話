# 【Rust】CLI で “戻るボタン” 的な挙動を実装した話

先日、CLI 上でディレクトリ移動を「戻る」ことができるツールを作り、
その使い方や挙動についての記事を投稿しました。

 **使い方・挙動についての記事はこちら**
https://zenn.dev/01mu/articles/c2cf2666067f56

この記事はその実装の振り返りです

- どんな技術を使ったか
- テーブル設計やデータの流れをどう考えたか
- AI（Codex / ChatGPT）をどう使っていたか

という 3 点でまとめました。

## 使用している技術について

このツールで使っている技術自体は、シンプルだと思います。

- Rust
- SQLite
- rusqlite
- シェル（bash / zsh 側のラッパー）

いままでCLIツールはShellScriptやPowerShellのみで書いており、
Rust は今回が初めてでしたが、AI（Codex / ChatGPT）のおかげてスムーズに開発を進めることができました。

- rusqlite を使った SQLite 操作
- CLI 引数まわり
- エラー処理の書き方

などなど...
基礎的な操作を含め、自分で一から調べて手で書いていたら、もっと時間がかかっていたと思います。

## SQLite と RDB 的な考え方での設計

状態管理には SQLite を使いました。

- 状態をテーブルとして切る
- データレコードがいつ増えて、いつ減るかを考える
- 不要になったものを一定サイクルで消す

など...
普段 PostgreSQL などで設計をしている私のRDB脳にハマりました。
SQLiteを学習用途以外で用いたのは初めてだったのですが、ローカルにおけるRDBとしてとても使い勝手がよいなと感じました。

## テーブル構成とデータフロー

テーブル構成自体はそこまで複雑ではありません。

### sessions テーブル

`sessions` は、
**シェル起動ごとの文脈を区別するためのテーブル**です。

- ターミナルを複数開く
- シェルを再起動する

といった状況を考えると、
履歴をすべて一つにまとめるのは後で困りそうだと思いました。

そのため、

- シェル起動ごとに session_id を発行
- 以降の操作はすべてこの session_id に紐づける

という形にしています。

**ライフサイクル**

- 生成：シェル起動時（または初回実行時）
- 使用：履歴や現在位置の管理
- 破棄：一定期間経過後に cleanup 対象

---

### events テーブル

`events` は、
**ディレクトリ移動そのものを記録するテーブル**です。

`cd` が実行されるたびに、

- session_id
- 移動先のパス
- 発生時刻

を 1 レコードとして保存しています。

**ライフサイクル**

- 生成：ディレクトリ移動時
- 使用：「戻る」操作の計算
- 破棄：セッション単位でまとめて cleanup

---

### undo_moves テーブル

`undo_moves` は、
**「戻る」操作をキャンセルするための一時データ**を持つテーブルです。

「戻る」を実行した直後に、

- どこから戻ったのか
- キャンセル時にどこへ戻すか

といった情報を保持します。

**ライフサイクル**

- 生成：「戻る」操作時
- 使用：直後のキャンセル操作
- 破棄：キャンセル完了、または次の移動時

---

## ライフサイクル設計と cleanup の考え方

ライフサイクルや cleanup の方針については、
正直なところ **明確な正解が分かっていたわけではありません**。

- どのくらい残すのが適切か
- いつ消すべきか
- どこまで厳密に管理するべきか

といった点は、
考え始めるときりがなく、判断基準も曖昧です。

実際には、

- ChatGPT に壁打ちしながら考えつつ
- 自分のこれまでの実務経験や感覚をベースに
- まずは無理のなさそうなところに落とす

という進め方をしました。

今のところの仮説としては、

> 人間が日常的に使う CLI ツールであれば、
> ライフサイクルは厳密に決めすぎなくても回る

と考えています。

---

## AI（Codex / ChatGPT）をどう使っていたか

今回の開発では、
Codex と ChatGPT をかなりラフに併用していました。

- Codex にコードを書いてもらう
- 自分で読んで動かす
- 分からないところを ChatGPT に聞く

という流れをひたすら繰り返しています。

「正解がある実装は任せる」といった
きれいな使い分けをしていたわけではなく、

> 書いてもらえるところは書いてもらって、
> 分からないところは理解する

という感覚です。

Rust 初学でも最後まで作り切れたのは、
このやり方のおかげだと思っています。

---

## 人間向けツールか、AI向けツールか

後から振り返って、

> これ、人間向けツールとして作っているな

と強く感じました。

もし AI が自動で使う前提だったら、

- セッションの数
- 履歴の増え方
- cleanup の考え方

などは、まったく別の設計になっていたと思います。

それでも今回は、

- 明確に人間向け
- 日常的に使う CLI ツール

という前提で割り切って作りました。

ツールを作りながら、
**人間向けか、AI向けかを無意識に切り分けて考えている自分**に気づいて、
少し面白いなと思いました。

---

## おわりに

今回の開発は、

- 初めての Rust
- 実装の中心は SQLite とデータ設計
- ライフサイクルをどう決めるかに一番悩んだ

という内容でした。

Rust の勉強というよりは、

> 状態を持つ CLI ツールをどう作るか

を考える良い題材だったと思います。

Codex と ChatGPT がなければ、
ここまでスムーズには進まなかったので、
その点でも良い経験でした。
